[
["index.html", "Data Analysis with Python Reference Book Day 1 Getting Started with Python", " Data Analysis with Python Reference Book Boyan Angelov and Rick Scavetta 2018-12-09 Day 1 Getting Started with Python Before running the commands in this book you should have the following software locally installed: Python from Anaconda Start the Anaconda Navigator and open up Jupyter Lab The workshop data repository can be found here. Please download and unzip the file. "],
["session-1-plant-growth-case-study.html", "Session 1: Plant Growth Case Study 1.1 Set up your environment 1.2 load dataset 1.3 Examine the data 1.4 Descriptive statistics 1.5 summary statistics 1.6 Plot 1.7 Inferential Statistics", " Session 1: Plant Growth Case Study Learning Objectives: Setting up Python Import data Performing descriptive and inferential statistics Plotting functions 1.1 Set up your environment 1.2 load dataset plant_growth = pd.read_csv(&#39;data/Plant Growth.txt&#39;, delimiter=&quot;\\t&quot;) 1.3 Examine the data # summaries plant_growth.describe() plant_growth[&#39;group&#39;].value_counts() # explore first dataset rows plant_growth.head() 1.4 Descriptive statistics # count group members plant_growth[&#39;group&#39;].value_counts() # get average weight np.mean(plant_growth[&#39;weight&#39;]) 1.5 summary statistics plant_growth.groupby([&#39;group&#39;]).describe() df1 = plant_growth.groupby([&#39;group&#39;]).mean() df2 = plant_growth.groupby([&#39;group&#39;]).std() final_df = pd.concat([df1, df2], axis=1) 1.6 Plot Visualize weight per group sns.boxplot(x=&#39;group&#39;, y=&#39;weight&#39;, data=plant_growth) ## AxesSubplot(0.672059,0.11;0.227941x0.77) 1.7 Inferential Statistics 1.7.1 T-test # fit a linear model # specify model model = ols(&quot;weight ~ group&quot;, plant_growth) # fit model results = model.fit() # explore model results results.summary() # extract coefficients results.params.Intercept results.params[&quot;group[T.trt1]&quot;] results.params[&quot;group[T.trt2]&quot;] 1.7.2 ANOVA # ANOVA # compute anova aov_table = sm.stats.anova_lm(results, typ=2) # explore anova results aov_table ## sum_sq df F PR(&gt;F) ## group 3.76634 2.0 4.846088 0.01591 ## Residual 10.49209 27.0 NaN NaN 1.7.3 Exercises Exercise 1.1 In the data folder you’ll find another file called “Chick Weights.txt”. Here you’ll find the results from an experiment in which newly hatched chicks were randomly allocated into six groups. Each group was given a different feed supplement. After six weeks, their weights in grams were measured. Using the commands we’ve learned so far complete the following tasks: Calculate the mean and standard deviation for each group. Calculate the number of chicks in each group. Calculate a within-group z-score. Produce a stripchart showing each chick as an individual data point Calculate a 1-way ANOVA. Calculate Tukey’s post-hoc test (i.e. p-values for all pair-wise t-tests) The results from the posthoc test will be as follows ## Multiple Comparison of Means - Tukey HSD,FWER=0.05 ## ============================================ ## group1 group2 meandiff lower upper reject ## -------------------------------------------- ## ctrl trt1 -0.371 -1.0621 0.3201 False ## ctrl trt2 0.494 -0.1971 1.1851 False ## trt1 trt2 0.865 0.1739 1.5561 True ## -------------------------------------------- "],
["session-2-the-fundamentals.html", "Session 2: The Fundamentals 1.8 Functions &amp; Methods 1.9 Containers - List and Dictionaries 1.10 Exercises", " Session 2: The Fundamentals Learning Objectives: Learn and use basic functions, methods and libraries Explore the most common data containers 1.8 Functions &amp; Methods Python is an object-oriented programming language. This means that objects have: Attributes, and Methods Methods are functions that an object can call on itself Functions are called on an object Let’s begin with functions 1.8.1 Generic function convention Functions have a generic form of: function(args) We already saw a lot of this, for example: np.log2(8) This actually uses NumPy, but we’ll talk about that in detail later. Typically, there is more than one way to call a funciton, for example: math.log(8, 2) would produce the same result. Let’s make a small data set to play with. We’ll consider different data containers in detail in the next section. heights = [167, 188, 178, 194, 171, 169] There are various things we can calculate on these values: sum(heights) len(heights) Table 1.1: Some common functions. Function Description len() The number of values, n np.mean() The mean stats.mode() The mode np.median() The median np.var() The variance np.std() The standard deviation stats.iqr() The inter-quartile range max() The maximum value min() The minimum value range() The range And we have methods that we call with a . notation. In this case, this does not work: l.len() # not a method e.g. methods are functions that an object calls, whereas you pass objects into functions. i.e. we pass l a list to the function len(), rather than calling the method len() on l using the . 1.8.2 periods Periods, ., have very specific meanings and use. They call methods taht are available. If you want to see the methods available to an object, you can just type . in jupyter lab and then tab to auto complete and see a list. For functions, you can get the help page by typing shift + tab inside the () of a function. You can’t use a . in a variable or function name. Let’s take a look at an example. Append a list: Call the append method on the list l using the dot notation. So your not passing l to the append() function, rather you’re calling the append() method on list l. l = [1, &quot;2&quot;, True] l.append(&#39;appended value&#39;) print(l) ## [1, &#39;2&#39;, True, &#39;appended value&#39;] Methods are special functions that belong to specific objects. e.g. if you try calling append on a dictionary object, you’ll get an error because the method append is not defined for a dictionary but it is defined for a list. 1.8.3 Exercises Exercise 1.2 Explore various methods for the object l and describe what they do. We’ll take them up together as a class. 1.9 Containers - List and Dictionaries 1.9.1 Homogenous Lists Let’s take a look at the different types: # Types a = 1 type(a) b = 0.25 type(b) c = &quot;Berlin&quot; type(c) d = True type(d) There are four data types in Python: Type Name Example int Integer numbers 7,9,2,-4 float Real numbers 3.14, 2.78, 6.45 bool Binary True and False str String All Alphanumeric and special characters As we’ve already seen, just use the assignment operator, =, for storing a value in a variable. Exercise 1.3 (Differences in handling types) What do expect when executing the following functions? 1 + 1 '1' + '1' '1' * 5 '1' '1' Exercise 1.4 (Mixing different lengths) So far, so good! But what would happen in these cases? [1, 6, 9, 36] + 100 [1, 6, 9, 36] + [10, 100] [1, 6, 9, 36] + [100, 200, 300, 400] [1, 6, 9, 36] + [100, &quot;dogs&quot;, 300, 400] Returning to methods, we have specific methods for strings: name = &quot;Berlin&quot; name.lower() name.upper() And similar functions: len(name) One of the most fundamental things in any language is know what type of data you are working with. If you have they wrong type, zou can’t calculate the things that you want to, so you’ll need to corece into a different type, for example str() is used to create a string. # coercion str(a) type(str(a)) 1.9.2 Heterogenous Lists Holds heterogeneous information (e.g., [3, 2.718, True, ‘hello’]) l = [1, &#39;2&#39;, True] print(l) ## [1, &#39;2&#39;, True] In Python we can have a list of lists which we would say has two dimensions, but that is beyone the scope of this introduction. 1.9.3 Dictionaries Lists are, for the most part, 1-dimensional. Dictionaries are 2-dimensional &amp; heterogenous, like many data sources you’ll enconter. Lists are unlabelled, but dictionaries provide key:value pairs using {} and :. d = {&#39;int_value&#39;:3, &#39;bool_value&#39;:False, &#39;str_value&#39;:&#39;hello&#39;} print(d) # ## {&#39;int_value&#39;: 3, &#39;bool_value&#39;: False, &#39;str_value&#39;: &#39;hello&#39;} print(d[&#39;str_value&#39;]) ## hello or course we can put two lists together to create a dictionary. We do this using dict(zip()). heights = [167, 188, 178, 194, 171, 169] persons = [&quot;Mary&quot;, &quot;John&quot;, &quot;Kevin&quot;, &quot;Elena&quot;, &quot;Doug&quot;, &quot;Galin&quot;] heights_persons = dict(zip(persons, heights)) There are specific methods to use here also: heights_persons.values() heights_persons.keys() Notice that the order when printing is different than in definition. Order is not guaranteed! So don’t rely on the printed order of the keys. l = [0, 1, 2, 3, 4] d = {&#39;int_value&#39;:3, &#39;bool_value&#39;:False, &#39;str_value&#39;:&#39;hello&#39;} print(len(l)) # ## 5 print(len(d)) ## 3 1.9.4 Libraries Lists and dictionaries are fine, but we want a bit more elegant soltuions. That’s where arrays, matrices and data frames come into play. Arrays and data frames are not in Python by default. They come from numby (array and matrix) and pandas (dataframe). Recall, that libraries just provide more functionality to Python. We use import to load the library. If we just use that, we get the entire library. import math What actually happened is this: from math import * So that we used the * as a wildcard. We can of course replace this with just a more specific part of the package, like so: from scipy.special import factorial So in this case we’re just importing a small part of the whole scipy.special library. We do this when there are potential conflicts or when it’s large. You also see that we can also give a package an alias that will save us typing later on. These are pretty much standard use for some packages and you shouldn’t change them! To do this use the as keyword as such: import numpy as np import pandas as pd 1.9.5 NumPy arrays # lists xx = [3, 8, 9, 23] print(xx) # but what yo ureally want is an np array ## [3, 8, 9, 23] xx = np.array([3, 8, 9, 23]) xx The primary reason we use NumPy arrays is to vectorize functions over all values. Let’s take a look at other common functions from NumPy that do this really well in table 1.1. 1.10 Exercises Exercise 1.5 Given the distances_from_berlin list: `distances_from_berlin = [584, 1054, 653, 2301, 2191] # Munich, Paris, Amsterdam, Madrid, Istanbul Answer the following questions: how many data points are there? What is the longest and shortest distance? Get the average distance Exercise 1.6 Modify the distances_meters list in the following ways: Remove the third distance Get the last distance in two ways (e.g. by looking at the data or by using proper positions) Get the second, third and fourth distances Get the distances in feet Exercise 1.7 Using the distances_meters list: Visualize the distances as a univariate strip plot or a histogram. "]
]
